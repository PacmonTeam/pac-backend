{"script":"// Sources flattened with hardhat v2.18.1 https://hardhat.org\n\n// SPDX-License-Identifier: MIT\n\n// File contracts/interfaces/IUniswapV2ERC20.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n// File contracts/interfaces/IUniswapV2Pair.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n\n// File contracts/interfaces/IERC20.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n}\n\n\n// File contracts/interfaces/IPriceFeed.sol\n\n// Original license: SPDX_License_Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n\n// File contracts/PacDemo.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\npragma solidity =0.8.20;\n\n\n\ncontract PacDemo {\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\n\n    address public gov;\n\n    address public token0;\n    address public token1;\n    address public pair;\n    address public pricefeed0;\n    address public pricefeed1;\n\n    bool public depositEnabled;\n    bool public withdrawEnabled;\n\n    mapping(address => uint256) public balances0;\n    mapping(address => uint256) public balances1;\n\n    modifier onlyGov() {\n        require(msg.sender == gov, 'only gov');\n        _;\n    }\n\n    constructor(\n        address _token0,\n        address _token1,\n        address _pair,\n        address _pricefeed0,\n        address _pricefeed1\n    ) {\n        gov = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n        pair = _pair;\n        pricefeed0 = _pricefeed0;\n        pricefeed1 = _pricefeed1;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (uint256 reserve0, uint256 reserve1)\n    {\n        (reserve0, reserve1, ) = IUniswapV2Pair(pair).getReserves();\n    }\n\n    function getPrice0() public view returns (uint256 price) {\n        (, int256 price0, , , ) = AggregatorV3Interface(pricefeed0)\n            .latestRoundData();\n        uint256 decimals0 = IERC20(token0).decimals();\n        price =\n            (uint256(price0) * PRICE_PRECISION) /\n            (10 ** AggregatorV3Interface(pricefeed0).decimals());\n    }\n\n    function getPrice1() public view returns (uint256 price) {\n        (, int256 price1, , , ) = AggregatorV3Interface(pricefeed1)\n            .latestRoundData();\n        price =\n            (uint256(price1) * PRICE_PRECISION) /\n            (10 ** AggregatorV3Interface(pricefeed1).decimals());\n    }\n\n    function getPrices() public view returns (uint256 price0, uint256 price1) {\n        price0 = getPrice0();\n        price1 = getPrice1();\n    }\n\n    function getAMMPrices()\n        public\n        view\n        returns (uint256 ammPrice0, uint256 ammPrice1)\n    {\n        uint256 decimals0 = IERC20(token0).decimals();\n        uint256 decimals1 = IERC20(token1).decimals();\n        (uint256 reserve0, uint256 reserve1) = getReserves();\n        ammPrice0 =\n            (reserve1 * PRICE_PRECISION * (10 ** decimals0)) /\n            reserve0 /\n            (10 ** decimals1);\n        ammPrice1 =\n            (reserve0 * PRICE_PRECISION * (10 ** decimals1)) /\n            reserve1 /\n            (10 ** decimals0);\n    }\n\n    function getValue0(address account) public view returns (uint256 value) {\n        uint256 balance0 = balances0[account];\n\n        (, int256 price0, , , ) = AggregatorV3Interface(pricefeed0)\n            .latestRoundData();\n\n        uint256 decimals0 = IERC20(token0).decimals();\n\n        value =\n            (balance0 * uint256(price0) * PRICE_PRECISION) /\n            (10 ** (decimals0 + AggregatorV3Interface(pricefeed0).decimals()));\n    }\n\n    function getValue1(address account) public view returns (uint256 value) {\n        uint256 balance1 = balances1[account];\n\n        (, int256 price1, , , ) = AggregatorV3Interface(pricefeed1)\n            .latestRoundData();\n\n        uint256 decimals1 = IERC20(token1).decimals();\n\n        value =\n            (balance1 * uint256(price1) * PRICE_PRECISION) /\n            (10 ** (decimals1 + AggregatorV3Interface(pricefeed1).decimals()));\n    }\n\n    function getValues(\n        address account\n    ) public view returns (uint256 value0, uint256 value1, uint256 value) {\n        value0 = getValue0(account);\n        value1 = getValue1(account);\n        value = value0 + value1;\n    }\n\n    function setDepositEnabled(bool _depositEnabled) public onlyGov {\n        depositEnabled = _depositEnabled;\n    }\n\n    function setWithdrawEnabled(bool _withdrawEnabled) public onlyGov {\n        withdrawEnabled = _withdrawEnabled;\n    }\n\n    function deposit(address token, uint256 amount) public {\n        require(depositEnabled, 'deposit disabled');\n        if (token == token0) {\n            balances0[msg.sender] += amount;\n        } else if (token == token1) {\n            balances1[msg.sender] += amount;\n        } else {\n            revert('invalid token');\n        }\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(address token, uint256 amount) public {\n        require(withdrawEnabled, 'withdraw disabled');\n        if (token == token0) {\n            require(\n                balances0[msg.sender] >= amount,\n                'insufficient balance of token0'\n            );\n            balances0[msg.sender] -= amount;\n        } else if (token == token1) {\n            require(\n                balances1[msg.sender] >= amount,\n                'insufficient balance of token1'\n            );\n            balances1[msg.sender] -= amount;\n        } else {\n            revert('invalid token');\n        }\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    function balance() public {\n        uint256 balance0 = balances0[msg.sender];\n        uint256 balance1 = balances1[msg.sender];\n\n        uint256 value0 = getValue0(msg.sender);\n        uint256 value1 = getValue1(msg.sender);\n\n        if (value0 > value1) {\n            uint256 amount = ((value0 - value1) * balance0) /\n                PRICE_PRECISION /\n                2;\n            balances0[msg.sender] -= amount;\n            _swap(token0, token1, amount);\n        } else if (value0 < value1) {\n            uint256 amount = ((value1 - value0) * balance1) /\n                PRICE_PRECISION /\n                2;\n            balances1[msg.sender] -= amount;\n            _swap(token1, token0, amount);\n        }\n    }\n\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 amount\n    ) public returns (uint256) {\n        require(\n            fromToken == token0 || fromToken == token1,\n            'invalid fromToken'\n        );\n        require(toToken == token0 || toToken == token1, 'invalid toToken');\n        require(fromToken != toToken, 'fromToken == toToken');\n        if (fromToken == token0) {\n            require(\n                balances0[msg.sender] >= amount,\n                'insufficient balance of token0'\n            );\n            balances0[msg.sender] -= amount;\n        } else {\n            require(\n                balances1[msg.sender] >= amount,\n                'insufficient balance of token1'\n            );\n            balances1[msg.sender] -= amount;\n        }\n        _swap(fromToken, toToken, amount);\n        return IERC20(toToken).balanceOf(address(this));\n    }\n\n    function _swap(address fromToken, address toToken, uint256 amount) public {\n        address pairToken0 = IUniswapV2Pair(pair).token0();\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair)\n            .getReserves();\n        IERC20(fromToken).transfer(pair, amount);\n        (uint256 reserveFrom, uint256 reserveTo) = fromToken == pairToken0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n        uint256 amountOut = _getAmountOut(amount, reserveFrom, reserveTo);\n        if (toToken == token0) {\n            IUniswapV2Pair(pair).swap(amountOut, 0, address(this), '');\n        } else {\n            IUniswapV2Pair(pair).swap(0, amountOut, address(this), '');\n        }\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            'UniswapV2Library: INSUFFICIENT_LIQUIDITY'\n        );\n        uint256 amountInWithFee = amountIn * 9970;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 10000 + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n}\n","configuration":"contractName: \"PacDemo\"\nconstructor:\n  - \"{{BTC}}\"\n  - \"{{USDC}}\"\n  - \"{{PAIR_BTC_USDC}}\"\n  - \"{{PRICEFEED_BTC}}\"\n  - \"{{PRICEFEED_USDC}}\"\nmanage:\n  functions:\n    - name: setDepositEnabled\n      arguments:\n        - name: enabled\n          type: boolean\n    - name: setWithdrawEnabled\n      arguments:\n        - name: enabled\n          type: boolean\noutput: \"DEMO_BANK\"\n"}